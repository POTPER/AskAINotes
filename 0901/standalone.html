<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>æ·±åŸºå‘ç›‘æµ‹ä¼ æ„Ÿå™¨å¸ƒç½®ç³»ç»Ÿ - GB50497-2019</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Microsoft YaHei', Arial, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            overflow: hidden;
        }

        #container {
            position: relative;
            width: 100vw;
            height: 100vh;
        }

        #canvas-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }

        #ui-panel {
            position: absolute;
            top: 20px;
            left: 20px;
            background: rgba(255, 255, 255, 0.9);
            backdrop-filter: blur(10px);
            border-radius: 15px;
            padding: 20px;
            box-shadow: 0 8px 32px rgba(31, 38, 135, 0.37);
            border: 1px solid rgba(255, 255, 255, 0.18);
            min-width: 320px;
            max-width: 400px;
            z-index: 1000;
        }

        #info-panel {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(255, 255, 255, 0.9);
            backdrop-filter: blur(10px);
            border-radius: 15px;
            padding: 20px;
            box-shadow: 0 8px 32px rgba(31, 38, 135, 0.37);
            border: 1px solid rgba(255, 255, 255, 0.18);
            min-width: 300px;
            z-index: 1000;
        }

        #validation-panel {
            position: absolute;
            bottom: 20px;
            left: 20px;
            background: rgba(255, 255, 255, 0.9);
            backdrop-filter: blur(10px);
            border-radius: 15px;
            padding: 20px;
            box-shadow: 0 8px 32px rgba(31, 38, 135, 0.37);
            border: 1px solid rgba(255, 255, 255, 0.18);
            min-width: 400px;
            z-index: 1000;
        }

        .panel-title {
            font-size: 18px;
            font-weight: bold;
            color: #333;
            margin-bottom: 15px;
            text-align: center;
            border-bottom: 2px solid #667eea;
            padding-bottom: 8px;
        }

        .control-group {
            margin-bottom: 15px;
        }

        .control-label {
            display: block;
            font-weight: bold;
            color: #555;
            margin-bottom: 5px;
        }

        .control-input {
            width: 100%;
            padding: 8px 12px;
            border: 2px solid #e0e0e0;
            border-radius: 8px;
            font-size: 14px;
            transition: border-color 0.3s;
        }

        .control-input:focus {
            outline: none;
            border-color: #667eea;
        }

        .btn {
            padding: 10px 20px;
            border: none;
            border-radius: 8px;
            font-size: 14px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s;
            margin: 5px;
        }

        .btn-primary {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
        }

        .btn-primary:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(102, 126, 234, 0.4);
        }

        .btn-secondary {
            background: #f8f9fa;
            color: #333;
            border: 2px solid #e0e0e0;
        }

        .btn-secondary:hover {
            background: #e9ecef;
        }

        .btn-danger {
            background: #dc3545;
            color: white;
        }

        .btn-danger:hover {
            background: #c82333;
            transform: translateY(-2px);
        }

        .sensor-list {
            max-height: 200px;
            overflow-y: auto;
            border: 1px solid #e0e0e0;
            border-radius: 8px;
            padding: 10px;
        }

        .sensor-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 8px;
            margin-bottom: 5px;
            background: #f8f9fa;
            border-radius: 5px;
        }

        .validation-result {
            padding: 10px;
            border-radius: 8px;
            margin-top: 10px;
        }

        .validation-success {
            background: #d4edda;
            color: #155724;
            border: 1px solid #c3e6cb;
        }

        .validation-warning {
            background: #fff3cd;
            color: #856404;
            border: 1px solid #ffeaa7;
        }

        .validation-error {
            background: #f8d7da;
            color: #721c24;
            border: 1px solid #f5c6cb;
        }

        .loading {
            text-align: center;
            padding: 20px;
            color: #666;
        }

        #status {
            position: absolute;
            bottom: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 10px;
            border-radius: 5px;
            font-family: monospace;
            z-index: 1001;
        }

        .sensor-sphere {
            cursor: pointer;
        }

        .sensor-sphere:hover {
            filter: brightness(1.2);
        }
    </style>
</head>
<body>
    <div id="container">
        <div id="canvas-container"></div>
        
        <!-- æ§åˆ¶é¢æ¿ -->
        <div id="ui-panel">
            <div class="panel-title">åŸºå‘ç›‘æµ‹ç³»ç»Ÿæ§åˆ¶å°</div>
            
            <div class="control-group">
                <label class="control-label">åŸºå‘ç±»å‹</label>
                <select id="pit-type" class="control-input">
                    <option value="soil">åœŸè´¨åŸºå‘</option>
                    <option value="rock">å²©ä½“åŸºå‘</option>
                    <option value="soil-rock">åœŸå²©ç»„åˆåŸºå‘</option>
                </select>
            </div>

            <div class="control-group">
                <label class="control-label">å®‰å…¨ç­‰çº§</label>
                <select id="safety-level" class="control-input">
                    <option value="1">ä¸€çº§</option>
                    <option value="2">äºŒçº§</option>
                    <option value="3">ä¸‰çº§</option>
                </select>
            </div>

            <div class="control-group">
                <label class="control-label">åŸºå‘æ·±åº¦ (m)</label>
                <input type="number" id="pit-depth" class="control-input" value="10" min="1" max="50">
            </div>

            <div class="control-group">
                <label class="control-label">åŸºå‘é•¿åº¦ (m)</label>
                <input type="number" id="pit-length" class="control-input" value="30" min="10" max="100">
            </div>

            <div class="control-group">
                <label class="control-label">åŸºå‘å®½åº¦ (m)</label>
                <input type="number" id="pit-width" class="control-input" value="20" min="10" max="100">
            </div>

            <div class="control-group">
                <button id="generate-pit" class="btn btn-primary">ç”ŸæˆåŸºå‘æ¨¡å‹</button>
                <button id="reset-view" class="btn btn-secondary">é‡ç½®è§†è§’</button>
            </div>

            <div class="control-group">
                <div class="control-label">ä¼ æ„Ÿå™¨ç±»å‹</div>
                <select id="sensor-type" class="control-input">
                    <option value="horizontal-displacement">å›´æŠ¤å¢™é¡¶éƒ¨æ°´å¹³ä½ç§»</option>
                    <option value="vertical-displacement">å›´æŠ¤å¢™é¡¶éƒ¨ç«–å‘ä½ç§»</option>
                    <option value="deep-horizontal">æ·±å±‚æ°´å¹³ä½ç§»</option>
                    <option value="support-force">æ”¯æ’‘è½´åŠ›</option>
                    <option value="anchor-force">é”šæ†è½´åŠ›</option>
                    <option value="water-level">åœ°ä¸‹æ°´ä½</option>
                    <option value="ground-settlement">å‘¨è¾¹åœ°è¡¨ç«–å‘ä½ç§»</option>
                </select>
            </div>

            <div class="control-group">
                <button id="place-sensor" class="btn btn-primary">å¸ƒç½®ä¼ æ„Ÿå™¨æ¨¡å¼</button>
                <button id="clear-sensors" class="btn btn-danger">æ¸…é™¤æ‰€æœ‰ä¼ æ„Ÿå™¨</button>
            </div>
        </div>

        <!-- ä¿¡æ¯é¢æ¿ -->
        <div id="info-panel">
            <div class="panel-title">ä¼ æ„Ÿå™¨ä¿¡æ¯</div>
            <div>THREE.js ç‰ˆæœ¬: <span id="three-version">åŠ è½½ä¸­...</span></div>
            <div>WebGL æ”¯æŒ: <span id="webgl-support">æ£€æµ‹ä¸­...</span></div>
            <div id="sensor-count">å·²å¸ƒç½®ä¼ æ„Ÿå™¨: 0 ä¸ª</div>
            <div class="sensor-list" id="sensor-list">
                <div class="loading">æš‚æ— ä¼ æ„Ÿå™¨</div>
            </div>
        </div>

        <!-- éªŒè¯ç»“æœé¢æ¿ -->
        <div id="validation-panel">
            <div class="panel-title">GB50497-2019 è§„èŒƒéªŒè¯</div>
            <button id="validate-layout" class="btn btn-primary">éªŒè¯ä¼ æ„Ÿå™¨å¸ƒç½®</button>
            <div id="validation-results">
                <div class="loading">ç‚¹å‡»éªŒè¯æŒ‰é’®æ£€æŸ¥ä¼ æ„Ÿå™¨å¸ƒç½®æ˜¯å¦ç¬¦åˆè§„èŒƒè¦æ±‚</div>
            </div>
        </div>

        <div id="status">æ­£åœ¨åŠ è½½THREE.js...</div>
    </div>

    <!-- ç›´æ¥ä»CDNåŠ è½½THREE.js -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r158/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.158.0/examples/js/controls/OrbitControls.js"></script>

    <script>
        // å…¨å±€åº”ç”¨å¯¹è±¡
        let app = null;

        // ç­‰å¾…THREE.jsåŠ è½½å®Œæˆ
        function waitForThree() {
            if (typeof THREE !== 'undefined') {
                console.log('THREE.js åŠ è½½å®Œæˆ');
                document.getElementById('three-version').textContent = THREE.REVISION;
                
                // æ£€æŸ¥WebGLæ”¯æŒ
                const canvas = document.createElement('canvas');
                const gl = canvas.getContext('webgl') || canvas.getContext('experimental-webgl');
                document.getElementById('webgl-support').textContent = gl ? 'âœ… æ”¯æŒ' : 'âŒ ä¸æ”¯æŒ';
                
                if (gl) {
                    initApp();
                } else {
                    document.getElementById('status').textContent = 'é”™è¯¯ï¼šæµè§ˆå™¨ä¸æ”¯æŒWebGL';
                }
            } else {
                setTimeout(waitForThree, 100);
            }
        }

        // åŸºå‘ç›‘æµ‹åº”ç”¨ç±»
        class ExcavationMonitoringApp {
            constructor() {
                this.scene = null;
                this.camera = null;
                this.renderer = null;
                this.controls = null;
                this.excavationGroup = new THREE.Group();
                this.sensorGroup = new THREE.Group();
                this.sensors = [];
                this.interactableObjects = [];
                this.placingSensor = false;
                this.currentSensorType = 'horizontal-displacement';
                this.raycaster = new THREE.Raycaster();
                this.mouse = new THREE.Vector2();
                
                this.init();
                this.setupEventListeners();
                this.animate();
            }

            init() {
                console.log('å¼€å§‹åˆå§‹åŒ–åº”ç”¨...');
                document.getElementById('status').textContent = 'æ­£åœ¨åˆå§‹åŒ–THREE.js...';

                // åˆ›å»ºåœºæ™¯
                this.scene = new THREE.Scene();
                this.scene.background = new THREE.Color(0x87CEEB);
                this.scene.fog = new THREE.Fog(0x87CEEB, 50, 200);

                // åˆ›å»ºç›¸æœº
                this.camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
                this.camera.position.set(50, 30, 50);

                // åˆ›å»ºæ¸²æŸ“å™¨
                this.renderer = new THREE.WebGLRenderer({ antialias: true });
                this.renderer.setSize(window.innerWidth, window.innerHeight);
                this.renderer.shadowMap.enabled = true;
                this.renderer.shadowMap.type = THREE.PCFSoftShadowMap;
                
                const container = document.getElementById('canvas-container');
                container.appendChild(this.renderer.domElement);

                // åˆ›å»ºæ§åˆ¶å™¨
                this.controls = new THREE.OrbitControls(this.camera, this.renderer.domElement);
                this.controls.enableDamping = true;
                this.controls.dampingFactor = 0.05;
                this.controls.maxPolarAngle = Math.PI / 2;

                // æ·»åŠ å…‰ç…§
                this.setupLighting();

                // åˆ›å»ºåœ°é¢
                this.createGround();

                // æ·»åŠ ç»„åˆ°åœºæ™¯
                this.scene.add(this.excavationGroup);
                this.scene.add(this.sensorGroup);

                // ç”Ÿæˆé»˜è®¤åŸºå‘
                this.generateExcavation();

                document.getElementById('status').textContent = 'ç³»ç»Ÿå°±ç»ª - å¯ä»¥å¼€å§‹å¸ƒç½®ä¼ æ„Ÿå™¨';
                console.log('åº”ç”¨åˆå§‹åŒ–å®Œæˆ');
            }

            setupLighting() {
                // ç¯å¢ƒå…‰
                const ambientLight = new THREE.AmbientLight(0x404040, 0.4);
                this.scene.add(ambientLight);

                // ä¸»å…‰æº
                const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
                directionalLight.position.set(50, 50, 25);
                directionalLight.castShadow = true;
                directionalLight.shadow.mapSize.width = 2048;
                directionalLight.shadow.mapSize.height = 2048;
                directionalLight.shadow.camera.near = 0.5;
                directionalLight.shadow.camera.far = 500;
                directionalLight.shadow.camera.left = -50;
                directionalLight.shadow.camera.right = 50;
                directionalLight.shadow.camera.top = 50;
                directionalLight.shadow.camera.bottom = -50;
                this.scene.add(directionalLight);

                // è¾…åŠ©å…‰æº
                const hemisphereLight = new THREE.HemisphereLight(0x87CEEB, 0x8B4513, 0.3);
                this.scene.add(hemisphereLight);
            }

            createGround() {
                // åˆ›å»ºåœ°é¢
                const groundGeometry = new THREE.PlaneGeometry(200, 200);
                const groundMaterial = new THREE.MeshLambertMaterial({ 
                    color: 0x90EE90,
                    transparent: true,
                    opacity: 0.7
                });
                const ground = new THREE.Mesh(groundGeometry, groundMaterial);
                ground.rotation.x = -Math.PI / 2;
                ground.position.y = 0;
                ground.receiveShadow = true;
                this.scene.add(ground);

                // æ·»åŠ ç½‘æ ¼
                const gridHelper = new THREE.GridHelper(200, 20, 0x888888, 0xAAAAAA);
                gridHelper.position.y = 0.01;
                this.scene.add(gridHelper);
            }

            generateExcavation() {
                console.log('å¼€å§‹ç”ŸæˆåŸºå‘æ¨¡å‹...');
                document.getElementById('status').textContent = 'æ­£åœ¨ç”ŸæˆåŸºå‘æ¨¡å‹...';
                
                // æ¸…é™¤ç°æœ‰åŸºå‘
                this.excavationGroup.clear();
                this.interactableObjects = [];

                const pitType = document.getElementById('pit-type').value;
                const safetyLevel = parseInt(document.getElementById('safety-level').value);
                const depth = parseFloat(document.getElementById('pit-depth').value);
                const length = parseFloat(document.getElementById('pit-length').value);
                const width = parseFloat(document.getElementById('pit-width').value);

                console.log('åŸºå‘å‚æ•°:', { pitType, safetyLevel, depth, length, width });

                // åˆ›å»ºåŸºå‘
                this.createExcavationModel(length, width, depth, pitType);

                document.getElementById('status').textContent = `åŸºå‘æ¨¡å‹ç”Ÿæˆå®Œæˆ - ${pitType} (${safetyLevel}çº§, ${length}x${width}x${depth}m)`;
                
                // é‡ç½®è§†è§’
                this.resetView();
                
                console.log('åŸºå‘æ¨¡å‹ç”Ÿæˆå®Œæˆ');
            }

            createExcavationModel(length, width, depth, type) {
                // åˆ›å»ºå›´æŠ¤å¢™
                const wallMaterial = new THREE.MeshPhongMaterial({ color: 0xCCCCCC });
                const wallThickness = 0.8;
                const wallHeight = depth + 2;
                
                // å››é¢å›´æŠ¤å¢™
                const walls = [
                    { pos: [length/2 + wallThickness/2, wallHeight/2 - 1, 0], size: [wallThickness, wallHeight, width] },
                    { pos: [-length/2 - wallThickness/2, wallHeight/2 - 1, 0], size: [wallThickness, wallHeight, width] },
                    { pos: [0, wallHeight/2 - 1, width/2 + wallThickness/2], size: [length, wallHeight, wallThickness] },
                    { pos: [0, wallHeight/2 - 1, -width/2 - wallThickness/2], size: [length, wallHeight, wallThickness] }
                ];

                walls.forEach((wall, index) => {
                    const geometry = new THREE.BoxGeometry(...wall.size);
                    const mesh = new THREE.Mesh(geometry, wallMaterial);
                    mesh.position.set(...wall.pos);
                    mesh.castShadow = true;
                    mesh.receiveShadow = true;
                    mesh.userData = { type: 'retaining-wall', id: index };
                    this.excavationGroup.add(mesh);
                    this.interactableObjects.push(mesh);
                });

                // æ ¹æ®ç±»å‹åˆ›å»ºåœ°è´¨ç»“æ„
                this.createGeologyStructure(length, width, depth, type);

                // åˆ›å»ºæ”¯æ’‘ç³»ç»Ÿ
                this.createSupports(length, width, depth);

                // åˆ›å»ºå† æ¢
                this.createCrownBeam(length, width);
            }

            createGeologyStructure(length, width, depth, type) {
                switch (type) {
                    case 'soil':
                        this.createSoilLayers(length, width, depth);
                        break;
                    case 'rock':
                        this.createRockLayer(length, width, depth);
                        break;
                    case 'soil-rock':
                        this.createSoilRockLayers(length, width, depth);
                        break;
                }
            }

            createSoilLayers(length, width, depth) {
                const layers = [
                    { height: depth * 0.3, color: 0xD2691E, name: 'å¡«åœŸå±‚' },
                    { height: depth * 0.4, color: 0xCD853F, name: 'ç²˜åœŸå±‚' },
                    { height: depth * 0.3, color: 0x8B4513, name: 'ç ‚åœŸå±‚' }
                ];

                let currentY = 0;
                layers.forEach((layer, index) => {
                    const geometry = new THREE.BoxGeometry(length + 10, layer.height, width + 10);
                    const material = new THREE.MeshLambertMaterial({ 
                        color: layer.color,
                        transparent: true,
                        opacity: 0.6
                    });
                    
                    const mesh = new THREE.Mesh(geometry, material);
                    mesh.position.set(0, currentY - layer.height/2, 0);
                    mesh.receiveShadow = true;
                    mesh.userData = { type: 'soil-layer', name: layer.name };
                    
                    this.excavationGroup.add(mesh);
                    currentY -= layer.height;
                });
            }

            createRockLayer(length, width, depth) {
                const geometry = new THREE.BoxGeometry(length + 10, depth, width + 10);
                const material = new THREE.MeshLambertMaterial({ 
                    color: 0x696969,
                    transparent: true,
                    opacity: 0.8
                });
                const mesh = new THREE.Mesh(geometry, material);
                mesh.position.set(0, -depth/2, 0);
                mesh.receiveShadow = true;
                mesh.userData = { type: 'rock-layer', name: 'å²©ä½“' };
                
                this.excavationGroup.add(mesh);
            }

            createSoilRockLayers(length, width, depth) {
                // ä¸Šéƒ¨åœŸå±‚
                const soilHeight = depth * 0.6;
                const soilGeometry = new THREE.BoxGeometry(length + 10, soilHeight, width + 10);
                const soilMaterial = new THREE.MeshLambertMaterial({ 
                    color: 0x8B4513,
                    transparent: true,
                    opacity: 0.6
                });
                const soilMesh = new THREE.Mesh(soilGeometry, soilMaterial);
                soilMesh.position.set(0, -soilHeight/2, 0);
                soilMesh.receiveShadow = true;
                soilMesh.userData = { type: 'soil-layer', name: 'åœŸå±‚' };
                this.excavationGroup.add(soilMesh);

                // ä¸‹éƒ¨å²©å±‚
                const rockHeight = depth * 0.4;
                const rockGeometry = new THREE.BoxGeometry(length + 10, rockHeight, width + 10);
                const rockMaterial = new THREE.MeshLambertMaterial({ 
                    color: 0x696969,
                    transparent: true,
                    opacity: 0.8
                });
                const rockMesh = new THREE.Mesh(rockGeometry, rockMaterial);
                rockMesh.position.set(0, -soilHeight - rockHeight/2, 0);
                rockMesh.receiveShadow = true;
                rockMesh.userData = { type: 'rock-layer', name: 'å²©å±‚' };
                this.excavationGroup.add(rockMesh);
            }

            createSupports(length, width, depth) {
                const supportMaterial = new THREE.MeshPhongMaterial({ color: 0x4169E1 });
                const supportRadius = 0.3;
                
                // åˆ›å»ºæ°´å¹³æ”¯æ’‘
                if (length > 15 || width > 15) {
                    const supportGeometry = new THREE.CylinderGeometry(supportRadius, supportRadius, length - 4);
                    const support1 = new THREE.Mesh(supportGeometry, supportMaterial);
                    support1.position.set(0, -depth/3, 0);
                    support1.rotation.z = Math.PI / 2;
                    support1.castShadow = true;
                    support1.userData = { type: 'support', level: 0 };
                    this.excavationGroup.add(support1);
                    this.interactableObjects.push(support1);

                    if (depth > 8) {
                        const support2 = new THREE.Mesh(supportGeometry, supportMaterial);
                        support2.position.set(0, -2*depth/3, 0);
                        support2.rotation.z = Math.PI / 2;
                        support2.castShadow = true;
                        support2.userData = { type: 'support', level: 1 };
                        this.excavationGroup.add(support2);
                        this.interactableObjects.push(support2);
                    }
                }

                // åˆ›å»ºç«‹æŸ±
                const columnRadius = 0.4;
                const columnGeometry = new THREE.CylinderGeometry(columnRadius, columnRadius, depth + 2);
                const columnMesh = new THREE.Mesh(columnGeometry, supportMaterial);
                columnMesh.position.set(0, -depth/2, 0);
                columnMesh.castShadow = true;
                columnMesh.userData = { type: 'column', id: 0 };
                this.excavationGroup.add(columnMesh);
                this.interactableObjects.push(columnMesh);
            }

            createCrownBeam(length, width) {
                const beamMaterial = new THREE.MeshPhongMaterial({ color: 0xCCCCCC });
                const beamSize = 0.6;
                
                const beamPositions = [
                    [length/2 + 0.4, 1 + beamSize/2, 0, length + 0.8, beamSize, beamSize],
                    [-length/2 - 0.4, 1 + beamSize/2, 0, length + 0.8, beamSize, beamSize],
                    [0, 1 + beamSize/2, width/2 + 0.4, beamSize, beamSize, width + 0.8],
                    [0, 1 + beamSize/2, -width/2 - 0.4, beamSize, beamSize, width + 0.8]
                ];

                beamPositions.forEach((pos, index) => {
                    const geometry = new THREE.BoxGeometry(pos[3], pos[4], pos[5]);
                    const mesh = new THREE.Mesh(geometry, beamMaterial);
                    mesh.position.set(pos[0], pos[1], pos[2]);
                    mesh.castShadow = true;
                    mesh.userData = { type: 'crown-beam', id: index };
                    
                    this.excavationGroup.add(mesh);
                    this.interactableObjects.push(mesh);
                });
            }

            // ä¼ æ„Ÿå™¨ç›¸å…³æ–¹æ³•
            placeSensor(type, position) {
                const sensorColors = {
                    'horizontal-displacement': 0xFF0000,
                    'vertical-displacement': 0x00FF00,
                    'deep-horizontal': 0x0000FF,
                    'support-force': 0xFFFF00,
                    'anchor-force': 0xFF00FF,
                    'water-level': 0x00FFFF,
                    'ground-settlement': 0xFFA500
                };

                const sensorGeometry = new THREE.SphereGeometry(0.5, 8, 6);
                const sensorMaterial = new THREE.MeshPhongMaterial({ 
                    color: sensorColors[type] || 0xFF0000,
                    emissive: sensorColors[type] || 0xFF0000,
                    emissiveIntensity: 0.2
                });
                
                const sensor = new THREE.Mesh(sensorGeometry, sensorMaterial);
                sensor.position.copy(position);
                sensor.castShadow = true;
                sensor.userData = { 
                    type: type, 
                    position: position.clone(),
                    timestamp: Date.now()
                };

                this.sensorGroup.add(sensor);
                this.sensors.push({
                    type: type,
                    position: position.clone(),
                    mesh: sensor,
                    id: this.sensors.length
                });

                this.updateSensorList();
                return true;
            }

            clearAllSensors() {
                this.sensors.forEach(sensor => {
                    this.sensorGroup.remove(sensor.mesh);
                });
                this.sensors = [];
                this.updateSensorList();
            }

            removeSensor(index) {
                if (index >= 0 && index < this.sensors.length) {
                    const sensor = this.sensors[index];
                    this.sensorGroup.remove(sensor.mesh);
                    this.sensors.splice(index, 1);
                    
                    // æ›´æ–°å‰©ä½™ä¼ æ„Ÿå™¨çš„ID
                    this.sensors.forEach((s, i) => s.id = i);
                    this.updateSensorList();
                }
            }

            updateSensorList() {
                const sensorCount = document.getElementById('sensor-count');
                const sensorList = document.getElementById('sensor-list');

                sensorCount.textContent = `å·²å¸ƒç½®ä¼ æ„Ÿå™¨: ${this.sensors.length} ä¸ª`;

                if (this.sensors.length === 0) {
                    sensorList.innerHTML = '<div class="loading">æš‚æ— ä¼ æ„Ÿå™¨</div>';
                    return;
                }

                const sensorTypeNames = {
                    'horizontal-displacement': 'å›´æŠ¤å¢™é¡¶éƒ¨æ°´å¹³ä½ç§»',
                    'vertical-displacement': 'å›´æŠ¤å¢™é¡¶éƒ¨ç«–å‘ä½ç§»',
                    'deep-horizontal': 'æ·±å±‚æ°´å¹³ä½ç§»',
                    'support-force': 'æ”¯æ’‘è½´åŠ›',
                    'anchor-force': 'é”šæ†è½´åŠ›',
                    'water-level': 'åœ°ä¸‹æ°´ä½',
                    'ground-settlement': 'å‘¨è¾¹åœ°è¡¨ç«–å‘ä½ç§»'
                };

                sensorList.innerHTML = this.sensors.map((sensor, index) => `
                    <div class="sensor-item">
                        <span>${sensorTypeNames[sensor.type] || sensor.type}</span>
                        <button onclick="app.removeSensor(${index})" class="btn btn-danger" style="padding: 2px 8px; font-size: 12px;">åˆ é™¤</button>
                    </div>
                `).join('');
            }

            // éªŒè¯ä¼ æ„Ÿå™¨å¸ƒç½®
            validateSensorLayout() {
                const pitType = document.getElementById('pit-type').value;
                const safetyLevel = parseInt(document.getElementById('safety-level').value);
                const depth = parseFloat(document.getElementById('pit-depth').value);
                const length = parseFloat(document.getElementById('pit-length').value);
                const width = parseFloat(document.getElementById('pit-width').value);

                const config = { type: pitType, safetyLevel, dimensions: { length, width, depth } };
                const results = this.performValidation(config, this.sensors);
                this.displayValidationResults(results);
            }

            performValidation(config, sensors) {
                // ç®€åŒ–çš„éªŒè¯é€»è¾‘
                const results = {
                    isValid: true,
                    errors: [],
                    warnings: [],
                    suggestions: []
                };

                const sensorTypes = sensors.map(s => s.type);
                const sensorCounts = {};
                sensorTypes.forEach(type => {
                    sensorCounts[type] = (sensorCounts[type] || 0) + 1;
                });

                // æ ¹æ®GB50497-2019æ ‡å‡†æ£€æŸ¥å¿…æµ‹é¡¹ç›®
                const requiredSensors = this.getRequiredSensors(config.type, config.safetyLevel);
                
                requiredSensors.forEach(required => {
                    if (!sensorCounts[required]) {
                        results.errors.push(`ç¼ºå°‘å¿…æµ‹é¡¹ç›®ï¼š${this.getSensorTypeName(required)}`);
                        results.isValid = false;
                    }
                });

                // æ£€æŸ¥ä¼ æ„Ÿå™¨æ•°é‡
                if (sensors.length < 8) {
                    results.warnings.push('ä¼ æ„Ÿå™¨æ€»æ•°é‡åå°‘ï¼Œå»ºè®®å¢åŠ ç›‘æµ‹ç‚¹');
                }

                // æ£€æŸ¥å¸ƒç½®ä½ç½®
                const wallSensors = sensors.filter(s => 
                    s.type === 'horizontal-displacement' || s.type === 'vertical-displacement'
                );
                
                if (wallSensors.length < 8) {
                    results.warnings.push('å›´æŠ¤å¢™ä½ç§»ç›‘æµ‹ç‚¹æ•°é‡ä¸è¶³ï¼Œå»ºè®®æ¯è¾¹è‡³å°‘å¸ƒç½®3ä¸ª');
                }

                if (results.errors.length === 0 && results.warnings.length === 0) {
                    results.suggestions.push('ä¼ æ„Ÿå™¨å¸ƒç½®åŸºæœ¬åˆç†ï¼Œç¬¦åˆè§„èŒƒè¦æ±‚');
                }

                return results;
            }

            getRequiredSensors(type, safetyLevel) {
                const requirements = {
                    soil: {
                        1: ['horizontal-displacement', 'vertical-displacement', 'deep-horizontal', 'support-force', 'water-level', 'ground-settlement'],
                        2: ['horizontal-displacement', 'vertical-displacement', 'deep-horizontal', 'support-force', 'water-level', 'ground-settlement'],
                        3: ['horizontal-displacement', 'vertical-displacement', 'water-level']
                    },
                    rock: {
                        1: ['horizontal-displacement', 'vertical-displacement', 'anchor-force', 'ground-settlement'],
                        2: ['horizontal-displacement', 'ground-settlement'],
                        3: ['horizontal-displacement']
                    },
                    'soil-rock': {
                        1: ['horizontal-displacement', 'vertical-displacement', 'deep-horizontal', 'support-force', 'anchor-force', 'water-level', 'ground-settlement'],
                        2: ['horizontal-displacement', 'vertical-displacement', 'deep-horizontal', 'support-force', 'water-level', 'ground-settlement'],
                        3: ['horizontal-displacement', 'vertical-displacement', 'water-level']
                    }
                };

                return requirements[type] ? requirements[type][safetyLevel] || [] : [];
            }

            getSensorTypeName(type) {
                const names = {
                    'horizontal-displacement': 'å›´æŠ¤å¢™é¡¶éƒ¨æ°´å¹³ä½ç§»',
                    'vertical-displacement': 'å›´æŠ¤å¢™é¡¶éƒ¨ç«–å‘ä½ç§»',
                    'deep-horizontal': 'æ·±å±‚æ°´å¹³ä½ç§»',
                    'support-force': 'æ”¯æ’‘è½´åŠ›',
                    'anchor-force': 'é”šæ†è½´åŠ›',
                    'water-level': 'åœ°ä¸‹æ°´ä½',
                    'ground-settlement': 'å‘¨è¾¹åœ°è¡¨ç«–å‘ä½ç§»'
                };
                return names[type] || type;
            }

            displayValidationResults(results) {
                const container = document.getElementById('validation-results');
                
                if (results.isValid && results.warnings.length === 0) {
                    container.innerHTML = `
                        <div class="validation-result validation-success">
                            <h4>âœ… éªŒè¯é€šè¿‡</h4>
                            <p>ä¼ æ„Ÿå™¨å¸ƒç½®ç¬¦åˆ GB50497-2019 æ ‡å‡†è¦æ±‚</p>
                        </div>
                    `;
                } else {
                    let html = '';
                    
                    if (results.errors.length > 0) {
                        html += `
                            <div class="validation-result validation-error">
                                <h4>âŒ ä¸ç¬¦åˆè§„èŒƒè¦æ±‚</h4>
                                <ul>
                                    ${results.errors.map(error => `<li>${error}</li>`).join('')}
                                </ul>
                            </div>
                        `;
                    }
                    
                    if (results.warnings.length > 0) {
                        html += `
                            <div class="validation-result validation-warning">
                                <h4>âš ï¸ å»ºè®®æ”¹è¿›</h4>
                                <ul>
                                    ${results.warnings.map(warning => `<li>${warning}</li>`).join('')}
                                </ul>
                            </div>
                        `;
                    }

                    if (results.suggestions.length > 0) {
                        html += `
                            <div class="validation-result validation-success">
                                <h4>ğŸ’¡ å»ºè®®</h4>
                                <ul>
                                    ${results.suggestions.map(suggestion => `<li>${suggestion}</li>`).join('')}
                                </ul>
                            </div>
                        `;
                    }
                    
                    container.innerHTML = html;
                }
            }

            // äº‹ä»¶å¤„ç†
            setupEventListeners() {
                // çª—å£å¤§å°è°ƒæ•´
                window.addEventListener('resize', () => this.onWindowResize());

                // é¼ æ ‡äº‹ä»¶
                this.renderer.domElement.addEventListener('click', (event) => this.onMouseClick(event));
                this.renderer.domElement.addEventListener('mousemove', (event) => this.onMouseMove(event));

                // UIæ§åˆ¶äº‹ä»¶
                document.getElementById('generate-pit').addEventListener('click', () => this.generateExcavation());
                document.getElementById('reset-view').addEventListener('click', () => this.resetView());
                document.getElementById('place-sensor').addEventListener('click', () => this.toggleSensorPlacement());
                document.getElementById('clear-sensors').addEventListener('click', () => this.clearAllSensors());
                document.getElementById('validate-layout').addEventListener('click', () => this.validateSensorLayout());
                
                // ä¼ æ„Ÿå™¨ç±»å‹é€‰æ‹©
                document.getElementById('sensor-type').addEventListener('change', (e) => {
                    this.currentSensorType = e.target.value;
                });
            }

            toggleSensorPlacement() {
                this.placingSensor = !this.placingSensor;
                const button = document.getElementById('place-sensor');
                
                if (this.placingSensor) {
                    button.textContent = 'é€€å‡ºå¸ƒç½®æ¨¡å¼';
                    button.classList.remove('btn-primary');
                    button.classList.add('btn-danger');
                    this.renderer.domElement.style.cursor = 'crosshair';
                    document.getElementById('status').textContent = 'ä¼ æ„Ÿå™¨å¸ƒç½®æ¨¡å¼ - ç‚¹å‡»æ¨¡å‹æ”¾ç½®ä¼ æ„Ÿå™¨';
                } else {
                    button.textContent = 'å¸ƒç½®ä¼ æ„Ÿå™¨æ¨¡å¼';
                    button.classList.remove('btn-danger');
                    button.classList.add('btn-primary');
                    this.renderer.domElement.style.cursor = 'default';
                    document.getElementById('status').textContent = 'ç³»ç»Ÿå°±ç»ª';
                }
            }

            onMouseClick(event) {
                if (!this.placingSensor) return;

                this.mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
                this.mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

                this.raycaster.setFromCamera(this.mouse, this.camera);
                
                const intersects = this.raycaster.intersectObjects(this.interactableObjects);
                
                if (intersects.length > 0) {
                    const point = intersects[0].point;
                    this.placeSensor(this.currentSensorType, point);
                    document.getElementById('status').textContent = `ä¼ æ„Ÿå™¨å¸ƒç½®æˆåŠŸ - å·²å¸ƒç½® ${this.sensors.length} ä¸ª`;
                }
            }

            onMouseMove(event) {
                if (!this.placingSensor) return;

                this.mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
                this.mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

                this.raycaster.setFromCamera(this.mouse, this.camera);
                
                const intersects = this.raycaster.intersectObjects(this.interactableObjects);
                
                if (intersects.length > 0) {
                    this.renderer.domElement.style.cursor = 'crosshair';
                } else {
                    this.renderer.domElement.style.cursor = 'not-allowed';
                }
            }

            resetView() {
                const length = parseFloat(document.getElementById('pit-length').value);
                const width = parseFloat(document.getElementById('pit-width').value);
                const maxDim = Math.max(length, width);
                
                this.camera.position.set(maxDim * 0.8, maxDim * 0.6, maxDim * 0.8);
                this.controls.target.set(0, 0, 0);
                this.controls.update();
            }

            onWindowResize() {
                this.camera.aspect = window.innerWidth / window.innerHeight;
                this.camera.updateProjectionMatrix();
                this.renderer.setSize(window.innerWidth, window.innerHeight);
            }

            animate() {
                requestAnimationFrame(() => this.animate());
                
                this.controls.update();
                
                // ä¼ æ„Ÿå™¨åŠ¨ç”»æ•ˆæœ
                this.sensors.forEach((sensor, index) => {
                    if (sensor.mesh) {
                        sensor.mesh.rotation.y += 0.01;
                        const scale = 1 + Math.sin(Date.now() * 0.003 + index) * 0.1;
                        sensor.mesh.scale.setScalar(scale);
                    }
                });
                
                this.renderer.render(this.scene, this.camera);
            }
        }

        // åˆå§‹åŒ–åº”ç”¨
        function initApp() {
            console.log('å¼€å§‹åˆå§‹åŒ–åŸºå‘ç›‘æµ‹åº”ç”¨...');
            app = new ExcavationMonitoringApp();
            window.app = app; // ä¾›HTMLæŒ‰é’®è°ƒç”¨
        }

        // å¼€å§‹åŠ è½½
        waitForThree();
    </script>
</body>
</html>
