<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>深基坑监测传感器布置系统</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Microsoft YaHei', Arial, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            overflow: hidden;
        }

        #container {
            position: relative;
            width: 100vw;
            height: 100vh;
        }

        #canvas-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }

        #ui-panel {
            position: absolute;
            top: 20px;
            left: 20px;
            background: rgba(255, 255, 255, 0.9);
            backdrop-filter: blur(10px);
            border-radius: 15px;
            padding: 20px;
            box-shadow: 0 8px 32px rgba(31, 38, 135, 0.37);
            border: 1px solid rgba(255, 255, 255, 0.18);
            min-width: 320px;
            z-index: 1000;
        }

        .panel-title {
            font-size: 18px;
            font-weight: bold;
            color: #333;
            margin-bottom: 15px;
            text-align: center;
            border-bottom: 2px solid #667eea;
            padding-bottom: 8px;
        }

        .control-group {
            margin-bottom: 15px;
        }

        .control-label {
            display: block;
            font-weight: bold;
            color: #555;
            margin-bottom: 5px;
        }

        .control-input {
            width: 100%;
            padding: 8px 12px;
            border: 2px solid #e0e0e0;
            border-radius: 8px;
            font-size: 14px;
            transition: border-color 0.3s;
        }

        .control-input:focus {
            outline: none;
            border-color: #667eea;
        }

        .btn {
            padding: 10px 20px;
            border: none;
            border-radius: 8px;
            font-size: 14px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s;
            margin: 5px;
        }

        .btn-primary {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
        }

        .btn-primary:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(102, 126, 234, 0.4);
        }

        .btn-secondary {
            background: #f8f9fa;
            color: #333;
            border: 2px solid #e0e0e0;
        }

        .btn-secondary:hover {
            background: #e9ecef;
        }

        .btn-danger {
            background: #dc3545;
            color: white;
        }

        .btn-danger:hover {
            background: #c82333;
            transform: translateY(-2px);
        }

        #status {
            position: absolute;
            bottom: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 10px;
            border-radius: 5px;
            font-family: monospace;
            z-index: 1001;
        }

        #info-panel {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(255, 255, 255, 0.9);
            backdrop-filter: blur(10px);
            border-radius: 15px;
            padding: 20px;
            box-shadow: 0 8px 32px rgba(31, 38, 135, 0.37);
            border: 1px solid rgba(255, 255, 255, 0.18);
            min-width: 300px;
            z-index: 1000;
        }

        .sensor-list {
            max-height: 200px;
            overflow-y: auto;
            border: 1px solid #e0e0e0;
            border-radius: 8px;
            padding: 10px;
            margin-top: 10px;
        }

        .sensor-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 8px;
            margin-bottom: 5px;
            background: #f8f9fa;
            border-radius: 5px;
        }

        .loading {
            text-align: center;
            padding: 20px;
            color: #666;
        }
    </style>
</head>
<body>
    <div id="container">
        <div id="canvas-container"></div>
        
        <!-- 控制面板 -->
        <div id="ui-panel">
            <div class="panel-title">基坑监测系统控制台</div>
            
            <div class="control-group">
                <label class="control-label">基坑类型</label>
                <select id="pit-type" class="control-input">
                    <option value="soil">土质基坑</option>
                    <option value="rock">岩体基坑</option>
                    <option value="soil-rock">土岩组合基坑</option>
                </select>
            </div>

            <div class="control-group">
                <label class="control-label">安全等级</label>
                <select id="safety-level" class="control-input">
                    <option value="1">一级</option>
                    <option value="2">二级</option>
                    <option value="3">三级</option>
                </select>
            </div>

            <div class="control-group">
                <label class="control-label">基坑深度 (m)</label>
                <input type="number" id="pit-depth" class="control-input" value="10" min="1" max="50">
            </div>

            <div class="control-group">
                <label class="control-label">基坑长度 (m)</label>
                <input type="number" id="pit-length" class="control-input" value="30" min="10" max="100">
            </div>

            <div class="control-group">
                <label class="control-label">基坑宽度 (m)</label>
                <input type="number" id="pit-width" class="control-input" value="20" min="10" max="100">
            </div>

            <div class="control-group">
                <button id="generate-pit" class="btn btn-primary">生成基坑模型</button>
                <button id="reset-view" class="btn btn-secondary">重置视角</button>
            </div>

            <div class="control-group">
                <div class="control-label">传感器类型</div>
                <select id="sensor-type" class="control-input">
                    <option value="horizontal-displacement">围护墙顶部水平位移</option>
                    <option value="vertical-displacement">围护墙顶部竖向位移</option>
                    <option value="deep-horizontal">深层水平位移</option>
                    <option value="support-force">支撑轴力</option>
                    <option value="anchor-force">锚杆轴力</option>
                    <option value="water-level">地下水位</option>
                    <option value="ground-settlement">周边地表竖向位移</option>
                </select>
            </div>

            <div class="control-group">
                <button id="place-sensor" class="btn btn-primary">布置传感器模式</button>
                <button id="clear-sensors" class="btn btn-danger">清除所有传感器</button>
            </div>
        </div>

        <!-- 信息面板 -->
        <div id="info-panel">
            <div class="panel-title">系统信息</div>
            <div>THREE.js: <span id="three-status">加载中...</span></div>
            <div>WebGL: <span id="webgl-status">检测中...</span></div>
            <div>基坑状态: <span id="pit-status">未生成</span></div>
            <div>传感器数量: <span id="sensor-count">0</span></div>
            
            <div class="sensor-list" id="sensor-list">
                <div class="loading">暂无传感器</div>
            </div>
        </div>

        <div id="status">正在加载系统...</div>
    </div>

    <!-- 使用可靠的CDN源加载THREE.js -->
    <script async src="https://unpkg.com/three@0.158.0/build/three.min.js"></script>
    <script async src="https://unpkg.com/three@0.158.0/examples/js/controls/OrbitControls.js"></script>

    <script>
        // 全局变量
        let scene, camera, renderer, controls;
        let excavationGroup, sensorGroup;
        let sensors = [];
        let interactableObjects = [];
        let placingSensor = false;
        let currentSensorType = 'horizontal-displacement';
        let raycaster, mouse;

        // 等待THREE.js加载
        function checkThreeJS() {
            if (typeof THREE !== 'undefined') {
                document.getElementById('three-status').textContent = '✅ 已加载 v' + THREE.REVISION;
                console.log('THREE.js loaded, version:', THREE.REVISION);
                
                // 检查WebGL
                const canvas = document.createElement('canvas');
                const gl = canvas.getContext('webgl') || canvas.getContext('experimental-webgl');
                
                if (gl) {
                    document.getElementById('webgl-status').textContent = '✅ 支持';
                    document.getElementById('status').textContent = '正在初始化3D引擎...';
                    initApp();
                } else {
                    document.getElementById('webgl-status').textContent = '❌ 不支持';
                    document.getElementById('status').textContent = '错误：浏览器不支持WebGL';
                }
            } else {
                setTimeout(checkThreeJS, 100);
            }
        }

        // 初始化应用
        function initApp() {
            try {
                console.log('开始初始化THREE.js应用...');
                
                // 创建场景
                scene = new THREE.Scene();
                scene.background = new THREE.Color(0x87CEEB);
                scene.fog = new THREE.Fog(0x87CEEB, 50, 200);
                console.log('场景创建完成');

                // 创建相机
                camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
                camera.position.set(50, 30, 50);
                console.log('相机创建完成');

                // 创建渲染器
                renderer = new THREE.WebGLRenderer({ antialias: true });
                renderer.setSize(window.innerWidth, window.innerHeight);
                renderer.shadowMap.enabled = true;
                renderer.shadowMap.type = THREE.PCFSoftShadowMap;
                
                const container = document.getElementById('canvas-container');
                container.appendChild(renderer.domElement);
                console.log('渲染器创建完成');

                // 创建控制器
                if (THREE.OrbitControls) {
                    controls = new THREE.OrbitControls(camera, renderer.domElement);
                    controls.enableDamping = true;
                    controls.dampingFactor = 0.05;
                    controls.maxPolarAngle = Math.PI / 2;
                    console.log('控制器创建完成');
                } else {
                    console.log('OrbitControls未加载，使用基本相机控制');
                }

                // 创建组
                excavationGroup = new THREE.Group();
                sensorGroup = new THREE.Group();
                scene.add(excavationGroup);
                scene.add(sensorGroup);

                // 创建射线检测器
                raycaster = new THREE.Raycaster();
                mouse = new THREE.Vector2();

                // 添加光照
                setupLighting();

                // 创建地面
                createGround();

                // 生成默认基坑
                generateExcavation();

                // 设置事件监听
                setupEventListeners();

                // 开始渲染循环
                animate();

                document.getElementById('status').textContent = '系统就绪 - 基坑模型已生成';
                console.log('应用初始化完成');

            } catch (error) {
                console.error('初始化失败:', error);
                document.getElementById('status').textContent = '初始化失败: ' + error.message;
            }
        }

        function setupLighting() {
            // 环境光
            const ambientLight = new THREE.AmbientLight(0x404040, 0.6);
            scene.add(ambientLight);

            // 主光源
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(50, 50, 25);
            directionalLight.castShadow = true;
            directionalLight.shadow.mapSize.width = 1024;
            directionalLight.shadow.mapSize.height = 1024;
            scene.add(directionalLight);

            console.log('光照设置完成');
        }

        function createGround() {
            // 创建地面
            const groundGeometry = new THREE.PlaneGeometry(200, 200);
            const groundMaterial = new THREE.MeshLambertMaterial({ 
                color: 0x90EE90,
                transparent: true,
                opacity: 0.7
            });
            const ground = new THREE.Mesh(groundGeometry, groundMaterial);
            ground.rotation.x = -Math.PI / 2;
            ground.position.y = 0;
            ground.receiveShadow = true;
            scene.add(ground);

            // 添加网格辅助线
            const gridHelper = new THREE.GridHelper(200, 20, 0x888888, 0xAAAAAA);
            gridHelper.position.y = 0.01;
            scene.add(gridHelper);

            console.log('地面创建完成');
        }

        function generateExcavation() {
            console.log('开始生成基坑模型...');
            document.getElementById('status').textContent = '正在生成基坑模型...';
            
            // 清除现有基坑
            excavationGroup.clear();
            interactableObjects = [];

            const pitType = document.getElementById('pit-type').value;
            const safetyLevel = parseInt(document.getElementById('safety-level').value);
            const depth = parseFloat(document.getElementById('pit-depth').value);
            const length = parseFloat(document.getElementById('pit-length').value);
            const width = parseFloat(document.getElementById('pit-width').value);

            console.log('基坑参数:', { pitType, safetyLevel, depth, length, width });

            try {
                // 创建围护墙
                createRetainingWalls(length, width, depth);
                
                // 创建地质结构
                createGeologyLayers(length, width, depth, pitType);
                
                // 创建支撑系统
                createSupportSystem(length, width, depth);

                // 更新状态
                document.getElementById('pit-status').textContent = `${pitType} (${safetyLevel}级, ${length}x${width}x${depth}m)`;
                document.getElementById('status').textContent = '基坑模型生成完成';
                
                // 重置视角
                resetView();
                
                console.log('基坑模型生成完成，对象数量:', excavationGroup.children.length);

            } catch (error) {
                console.error('基坑生成失败:', error);
                document.getElementById('status').textContent = '基坑生成失败: ' + error.message;
            }
        }

        function createRetainingWalls(length, width, depth) {
            const wallMaterial = new THREE.MeshPhongMaterial({ 
                color: 0xCCCCCC,
                shininess: 30
            });
            const wallThickness = 0.8;
            const wallHeight = depth + 2;
            
            // 四面围护墙
            const walls = [
                { pos: [length/2 + wallThickness/2, wallHeight/2 - 1, 0], size: [wallThickness, wallHeight, width + 2] },
                { pos: [-length/2 - wallThickness/2, wallHeight/2 - 1, 0], size: [wallThickness, wallHeight, width + 2] },
                { pos: [0, wallHeight/2 - 1, width/2 + wallThickness/2], size: [length + 2, wallHeight, wallThickness] },
                { pos: [0, wallHeight/2 - 1, -width/2 - wallThickness/2], size: [length + 2, wallHeight, wallThickness] }
            ];

            walls.forEach((wall, index) => {
                const geometry = new THREE.BoxGeometry(...wall.size);
                const mesh = new THREE.Mesh(geometry, wallMaterial);
                mesh.position.set(...wall.pos);
                mesh.castShadow = true;
                mesh.receiveShadow = true;
                mesh.userData = { type: 'retaining-wall', id: index };
                excavationGroup.add(mesh);
                interactableObjects.push(mesh);
            });

            console.log('围护墙创建完成');
        }

        function createGeologyLayers(length, width, depth, type) {
            switch (type) {
                case 'soil':
                    createSoilLayers(length, width, depth);
                    break;
                case 'rock':
                    createRockLayer(length, width, depth);
                    break;
                case 'soil-rock':
                    createSoilRockLayers(length, width, depth);
                    break;
            }
            console.log('地质结构创建完成');
        }

        function createSoilLayers(length, width, depth) {
            const layers = [
                { height: depth * 0.4, color: 0xD2691E, y: -depth * 0.2 },
                { height: depth * 0.6, color: 0x8B4513, y: -depth * 0.7 }
            ];

            layers.forEach((layer, index) => {
                const geometry = new THREE.BoxGeometry(length + 10, layer.height, width + 10);
                const material = new THREE.MeshLambertMaterial({ 
                    color: layer.color,
                    transparent: true,
                    opacity: 0.7
                });
                
                const mesh = new THREE.Mesh(geometry, material);
                mesh.position.set(0, layer.y, 0);
                mesh.receiveShadow = true;
                excavationGroup.add(mesh);
            });
        }

        function createRockLayer(length, width, depth) {
            const geometry = new THREE.BoxGeometry(length + 10, depth, width + 10);
            const material = new THREE.MeshLambertMaterial({ 
                color: 0x696969,
                transparent: true,
                opacity: 0.8
            });
            const mesh = new THREE.Mesh(geometry, material);
            mesh.position.set(0, -depth/2, 0);
            mesh.receiveShadow = true;
            excavationGroup.add(mesh);
        }

        function createSoilRockLayers(length, width, depth) {
            // 上部土层
            const soilHeight = depth * 0.6;
            const soilGeometry = new THREE.BoxGeometry(length + 10, soilHeight, width + 10);
            const soilMaterial = new THREE.MeshLambertMaterial({ 
                color: 0x8B4513,
                transparent: true,
                opacity: 0.6
            });
            const soilMesh = new THREE.Mesh(soilGeometry, soilMaterial);
            soilMesh.position.set(0, -soilHeight/2, 0);
            soilMesh.receiveShadow = true;
            excavationGroup.add(soilMesh);

            // 下部岩层
            const rockHeight = depth * 0.4;
            const rockGeometry = new THREE.BoxGeometry(length + 10, rockHeight, width + 10);
            const rockMaterial = new THREE.MeshLambertMaterial({ 
                color: 0x696969,
                transparent: true,
                opacity: 0.8
            });
            const rockMesh = new THREE.Mesh(rockGeometry, rockMaterial);
            rockMesh.position.set(0, -soilHeight - rockHeight/2, 0);
            rockMesh.receiveShadow = true;
            excavationGroup.add(rockMesh);
        }

        function createSupportSystem(length, width, depth) {
            const supportMaterial = new THREE.MeshPhongMaterial({ 
                color: 0x4169E1,
                shininess: 50
            });
            
            // 创建水平支撑
            if (length > 15) {
                const supportGeometry = new THREE.CylinderGeometry(0.3, 0.3, length - 4);
                const support1 = new THREE.Mesh(supportGeometry, supportMaterial);
                support1.position.set(0, -depth/3, 0);
                support1.rotation.z = Math.PI / 2;
                support1.castShadow = true;
                support1.userData = { type: 'support', level: 0 };
                excavationGroup.add(support1);
                interactableObjects.push(support1);

                if (depth > 8) {
                    const support2 = new THREE.Mesh(supportGeometry, supportMaterial);
                    support2.position.set(0, -2*depth/3, 0);
                    support2.rotation.z = Math.PI / 2;
                    support2.castShadow = true;
                    support2.userData = { type: 'support', level: 1 };
                    excavationGroup.add(support2);
                    interactableObjects.push(support2);
                }
            }

            // 创建立柱
            const columnGeometry = new THREE.CylinderGeometry(0.4, 0.4, depth + 2);
            const columnMesh = new THREE.Mesh(columnGeometry, supportMaterial);
            columnMesh.position.set(0, -depth/2, 0);
            columnMesh.castShadow = true;
            columnMesh.userData = { type: 'column', id: 0 };
            excavationGroup.add(columnMesh);
            interactableObjects.push(columnMesh);

            console.log('支撑系统创建完成');
        }

        // 传感器相关函数
        function placeSensor(type, position) {
            const sensorColors = {
                'horizontal-displacement': 0xFF0000,
                'vertical-displacement': 0x00FF00,
                'deep-horizontal': 0x0000FF,
                'support-force': 0xFFFF00,
                'anchor-force': 0xFF00FF,
                'water-level': 0x00FFFF,
                'ground-settlement': 0xFFA500
            };

            const sensorGeometry = new THREE.SphereGeometry(0.8, 12, 8);
            const sensorMaterial = new THREE.MeshPhongMaterial({ 
                color: sensorColors[type] || 0xFF0000,
                emissive: sensorColors[type] || 0xFF0000,
                emissiveIntensity: 0.3
            });
            
            const sensor = new THREE.Mesh(sensorGeometry, sensorMaterial);
            sensor.position.copy(position);
            sensor.castShadow = true;
            sensor.userData = { 
                type: type, 
                position: position.clone(),
                id: sensors.length
            };

            sensorGroup.add(sensor);
            sensors.push({
                type: type,
                position: position.clone(),
                mesh: sensor,
                id: sensors.length
            });

            updateSensorList();
            return true;
        }

        function clearAllSensors() {
            sensors.forEach(sensor => {
                sensorGroup.remove(sensor.mesh);
            });
            sensors = [];
            updateSensorList();
        }

        function removeSensor(index) {
            if (index >= 0 && index < sensors.length) {
                const sensor = sensors[index];
                sensorGroup.remove(sensor.mesh);
                sensors.splice(index, 1);
                
                // 更新ID
                sensors.forEach((s, i) => s.id = i);
                updateSensorList();
            }
        }

        function updateSensorList() {
            document.getElementById('sensor-count').textContent = sensors.length;
            const sensorList = document.getElementById('sensor-list');

            if (sensors.length === 0) {
                sensorList.innerHTML = '<div class="loading">暂无传感器</div>';
                return;
            }

            const sensorTypeNames = {
                'horizontal-displacement': '围护墙顶部水平位移',
                'vertical-displacement': '围护墙顶部竖向位移',
                'deep-horizontal': '深层水平位移',
                'support-force': '支撑轴力',
                'anchor-force': '锚杆轴力',
                'water-level': '地下水位',
                'ground-settlement': '周边地表竖向位移'
            };

            sensorList.innerHTML = sensors.map((sensor, index) => `
                <div class="sensor-item">
                    <span>${sensorTypeNames[sensor.type] || sensor.type}</span>
                    <button onclick="removeSensor(${index})" class="btn btn-danger" style="padding: 2px 8px; font-size: 12px;">删除</button>
                </div>
            `).join('');
        }

        // 事件处理
        function setupEventListeners() {
            // 窗口大小调整
            window.addEventListener('resize', onWindowResize);

            // 鼠标事件
            renderer.domElement.addEventListener('click', onMouseClick);
            renderer.domElement.addEventListener('mousemove', onMouseMove);

            // UI控制事件
            document.getElementById('generate-pit').addEventListener('click', generateExcavation);
            document.getElementById('reset-view').addEventListener('click', resetView);
            document.getElementById('place-sensor').addEventListener('click', toggleSensorPlacement);
            document.getElementById('clear-sensors').addEventListener('click', clearAllSensors);
            
            // 传感器类型选择
            document.getElementById('sensor-type').addEventListener('change', (e) => {
                currentSensorType = e.target.value;
            });

            console.log('事件监听器设置完成');
        }

        function toggleSensorPlacement() {
            placingSensor = !placingSensor;
            const button = document.getElementById('place-sensor');
            
            if (placingSensor) {
                button.textContent = '退出布置模式';
                button.classList.remove('btn-primary');
                button.classList.add('btn-danger');
                renderer.domElement.style.cursor = 'crosshair';
                document.getElementById('status').textContent = '传感器布置模式 - 点击模型放置传感器';
            } else {
                button.textContent = '布置传感器模式';
                button.classList.remove('btn-danger');
                button.classList.add('btn-primary');
                renderer.domElement.style.cursor = 'default';
                document.getElementById('status').textContent = '系统就绪';
            }
        }

        function onMouseClick(event) {
            if (!placingSensor) return;

            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

            raycaster.setFromCamera(mouse, camera);
            
            const intersects = raycaster.intersectObjects(interactableObjects);
            
            if (intersects.length > 0) {
                const point = intersects[0].point;
                placeSensor(currentSensorType, point);
                document.getElementById('status').textContent = `传感器布置成功 - 已布置 ${sensors.length} 个`;
            }
        }

        function onMouseMove(event) {
            if (!placingSensor) return;

            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

            raycaster.setFromCamera(mouse, camera);
            
            const intersects = raycaster.intersectObjects(interactableObjects);
            
            if (intersects.length > 0) {
                renderer.domElement.style.cursor = 'crosshair';
            } else {
                renderer.domElement.style.cursor = 'not-allowed';
            }
        }

        function resetView() {
            const length = parseFloat(document.getElementById('pit-length').value);
            const width = parseFloat(document.getElementById('pit-width').value);
            const maxDim = Math.max(length, width);
            
            camera.position.set(maxDim * 0.8, maxDim * 0.6, maxDim * 0.8);
            camera.lookAt(0, 0, 0);
            
            if (controls) {
                controls.target.set(0, 0, 0);
                controls.update();
            }
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function animate() {
            requestAnimationFrame(animate);
            
            if (controls) {
                controls.update();
            }
            
            // 传感器动画效果
            sensors.forEach((sensor, index) => {
                if (sensor.mesh) {
                    sensor.mesh.rotation.y += 0.02;
                    const scale = 1 + Math.sin(Date.now() * 0.003 + index) * 0.1;
                    sensor.mesh.scale.setScalar(scale);
                }
            });
            
            renderer.render(scene, camera);
        }

        // 开始加载
        document.addEventListener('DOMContentLoaded', () => {
            console.log('DOM加载完成，开始检查THREE.js...');
            checkThreeJS();
        });
    </script>
</body>
</html>

